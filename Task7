import numpy as np
import matplotlib.pyplot as plt


#1.Даны значения величины заработной платы заемщиков банка (zp) и значения их поведенческого кредитного 
#скоринга (ks): zp = [35, 45, 190, 200, 40, 70, 54, 150, 120, 110], ks = [401, 574, 874, 919, 459, 739, 653, 902, 746, 832]. 
 #   Используя математические операции, посчитать коэффициенты линейной регрессии, приняв за X заработную плату 
  #  (то есть, zp - признак), а за y - значения скорингового балла (то есть, ks - целевая переменная). Произвести 
   # расчет как с использованием intercept, так и без.
zp = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])   
ks = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])
n=10
x = zp
y = ks

#предположим, что наша модель y = b0 + b1*x
#посчитаем коэффициент b1 по формуле
b1 = (np.mean(zp * ks) - np.mean(zp) * np.mean(ks)) / (np.mean(zp**2) - np.mean(zp) ** 2)
print('коэффициэент b1',b) # 2.620538882402765
#посчитаем коэффициент b0 по формуле
b0 = np.mean(ks) - b * np.mean(zp)
print('коэффициэент b0',b0) # 444.1773573243596
# y = 444.17 + 2.62*x

#посчитаем матричным методом без интерсепта y = b1*x
X = x.reshape((n,1))   
Y = y.reshape((n,1))  
B0 = np.dot(np.linalg.inv(np.dot(X.T,X)),X.T@y)
print('коэффициент b0 модели без интерсепта',B0) # 5.88982042
# y = 5.89*x

#построим на графике точки наших наблюдений и две рассчитанных модели
plt.scatter(X, Y, color = "b", marker = "o", s = 30)
y_pred2 = B0*X 
plt.plot(X, y_pred2, color = "g") # модель без интерсепта y = b1*x
plt.plot(x, y_pred, color = "y") # y = b0 + b1*x
plt.xlabel('x')
plt.ylabel('y') 
plt.show()

#2.Посчитать коэффициент линейной регрессии при заработной плате (zp), используя градиентный спуск (без intercept).
def mse(B1,n,y=y,X=X):
    return np.sum((B1*X-y)**2)/n
B1 = 0.1
n = 10
alpha = 0.000001
x = zp
y = ks
for i in range(1000):
    B1 -= alpha*(2/n)*np.sum((B1*x-y)*x)
    if i%100==0:
        print(f'шаг {i} значение b1 = {B1}')
print('На 600 шаге значение b1 не меняется до 6 знака после запятой и равно 5.889820124983314')        
print('Итоговое значение коэффициента b1 =', B1) # 5.889820420065112
# y = 5.89*x
#построим график
plt.scatter(X, y, color = "b", marker = "o", s = 30)
y_pred3 = B1*x 
plt.plot(x, y_pred3, color = "g") 
plt.xlabel('x')
plt.ylabel('y') 
plt.show() 

#3.В каких случаях для вычисления доверительных интервалов и проверки статистических гипотез используется таблица значений 
#функции Лапласа, а в каких - таблица критических точек распределения Стьюдента?

'''
Критерий Стьюдента применяется, если случайная величина следует нормальному распределению.
Небольшое количество измерений. Непрерывная случайная величина.
Дисперсия ген. совокупности неизвестна.

Функция Лапласа, видимо это, z-критерий. 
Применяется, если случайная величина следует нормальному распределению.
Известна дисперсия генеральной совокупности.
Довольно большое количество измерений.
Непрерывная случайная величина.
'''

#*4. Произвести вычисления как в пункте 2, но с вычислением intercept. Учесть, что изменение коэффициентов должно производиться
#на каждом шаге одновременно (то есть изменение одного коэффициента не должно влиять на изменение другого во время одной итерации).

#будем использовать среднеквадратичную функцию потерь для расчета ошибки
def mse(B1,n,y=y,X=X):
    return np.sum((B1*X-y)**2)/n
#выбираем начальные значение коэффциентов b0 и b1 
B11 = 0.1
B01 = 1
n1 = 10
alpha1 = 0.00001 #выбираем коэффициент а
X1 = zp
y1 = ks

for i in range(10000000): #выбираем кол-во циклов, чтобы получить помалоизменяющееся значение
    yhat = B01 + B11 * X1 # наша модель
    #уточняем коэффициент b0, используя производную от функции потерь по b0
    B01 = B01 - alpha1 * 2*np.sum((yhat-y1))/n1
    #уточняем коэффициент b1, используя производную от функции потерь по b1
    B11 = B11 - alpha1 * 2*np.sum((yhat-y1)*X1)/n1
    if i%1000000==0:
        print(f'шаг {i} значение b1 = {B11}, b0 = {B01}')
#шаг 3000000 значение b1 = 2.620539683827264, b0 = 444.1772484417021        
print(B01,B11) 

#строим график
plt.scatter(X1, y1, color = "b", marker = "o", s = 30)
y_pred4 = B11*X1 + B01
plt.plot(X1, y_pred4, color = "g") 
plt.xlabel('x')
plt.ylabel('y') 
plt.show() 
